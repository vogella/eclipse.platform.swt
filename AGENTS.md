# AGENTS.md - Eclipse SWT Guide

This document provides comprehensive guidance for AI agents working with the Eclipse Standard Widget Toolkit (SWT) repository.

## Project Overview

Eclipse SWT (Standard Widget Toolkit) is a cross-platform GUI library for JVM-based desktop applications. It provides native OS bindings for Windows (Win32), macOS (Cocoa), and Linux (GTK3/GTK4). The most well-known SWT-based application is Eclipse IDE itself.

**Key Characteristics:**
- **Native Performance**: Direct bindings to platform UI APIs (no intermediate UI layer)
- **Cross-Platform**: Single Java API with platform-specific implementations
- **JNI-Heavy**: Extensive use of Java Native Interface for OS integration
- **Eclipse Platform Foundation**: Powers Eclipse IDE and Eclipse RCP applications

**Tech Stack:**
- Java 21
- Maven 3.9.11 with Tycho (OSGi/Eclipse plugin build system)
- Native code: C (GTK/Win32), Objective-C (macOS)
- Build tools: gcc, make, pkg-config, GTK development libraries

## Build System

### Maven/Tycho Build

**Full project build:**
```bash
mvn clean install
```

**Important Maven Notes:**
- This is a Tycho (OSGi) build, not a standard Maven project
- Tests run in the `integration-test` phase, not `test` phase
- Use `mvn verify` to run tests, not `mvn test`
- Build is platform-specific and automatically selects the correct profile

### Native Library Build

Native libraries must be rebuilt separately when modifying C/Objective-C code.

**GTK (Linux):**
```bash
cd bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library
./build.sh -gtk-all install    # Build both GTK3 and GTK4, copy to binaries
./build.sh -gtk3 install        # Build GTK3 only
./build.sh -gtk4 install        # Build GTK4 only
./build.sh clean                # Clean build artifacts
```

**Install build dependencies (Fedora/RHEL):**
```bash
bundles/org.eclipse.swt.tools/gtk/install_sysdeps.sh
```

**macOS (Cocoa):**
```bash
cd bundles/org.eclipse.swt/Eclipse SWT PI/cocoa/library
./build.sh
```

**Windows (Win32):**
See `bundles/org.eclipse.swt/Readme.Win32.md` for Visual Studio setup and build instructions.

### Generated Code Warning

**CRITICAL**: Several files are auto-generated by SWT Tools:
- `bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library/os.c`
- `bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library/os_stats.c`
- `bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library/os_stats.h`

**Never directly edit these files!** They are regenerated from Java source when the project is cleaned/rebuilt in Eclipse. Instead:
1. Modify the Java source (e.g., `OS.java`)
2. Clean and rebuild the `org.eclipse.swt` project
3. Rebuild native libraries with `./build.sh`

## Repository Structure

```
eclipse.platform.swt/
├── bundles/
│   ├── org.eclipse.swt/                   # Core SWT bundle
│   │   ├── Eclipse SWT/                   # Platform implementations
│   │   │   ├── gtk/                       # GTK (Linux) Java implementation
│   │   │   ├── cocoa/                     # macOS Java implementation
│   │   │   └── win32/                     # Windows Java implementation
│   │   ├── Eclipse SWT PI/                # Platform Interface (JNI) layer
│   │   │   ├── gtk/
│   │   │   │   ├── org/.../gtk/           # GTK JNI bindings (OS.java, etc.)
│   │   │   │   └── library/               # GTK native code (C)
│   │   │   ├── cocoa/library/             # macOS native code
│   │   │   └── win32/library/             # Windows native code
│   │   └── Eclipse SWT/common/            # Platform-independent widgets
│   ├── org.eclipse.swt.tools/             # JNI generator and build tools
│   └── org.eclipse.swt.svg/               # SVG support
├── binaries/                               # Compiled native libraries
│   ├── org.eclipse.swt.gtk.linux.x86_64/  # GTK .so files
│   ├── org.eclipse.swt.cocoa.macosx.x86_64/
│   └── org.eclipse.swt.win32.win32.x86_64/
├── examples/
│   ├── org.eclipse.swt.snippets/          # Small example programs
│   └── org.eclipse.swt.examples/          # Comprehensive demos
├── tests/
│   ├── org.eclipse.swt.tests/             # Cross-platform tests
│   ├── org.eclipse.swt.tests.gtk/         # GTK-specific tests
│   ├── org.eclipse.swt.tests.cocoa/       # macOS-specific tests
│   └── org.eclipse.swt.tests.win32/       # Windows-specific tests
└── docs/                                   # Developer guides
```

### Platform-Specific Code Organization

SWT uses **classpath switching** for platform-specific builds:
- `.classpath_gtk` - Linux/GTK classpath
- `.classpath_cocoa` - macOS classpath
- `.classpath_win32` - Windows classpath

When working in Eclipse IDE, rename the appropriate `.classpath_*` file to `.classpath` for your platform. Maven/Tycho handles this automatically during builds.

## Architecture

### Three-Layer Design

SWT implements a unified Java API with platform-specific backends:

1. **Public API Layer** (`org.eclipse.swt.widgets`, `org.eclipse.swt.graphics`, etc.)
   - Platform-independent widget classes: `Button`, `Shell`, `Display`, `Canvas`
   - Public API visible to application developers
   - Documentation must remain platform-agnostic

2. **Platform Implementation Layer** (`Eclipse SWT/<platform>/org/eclipse/swt/`)
   - Platform-specific implementations of widgets
   - Example: `Button.java` in `Eclipse SWT/gtk/` vs `Eclipse SWT/win32/`
   - Contains logic for creating and managing native widgets

3. **Platform Interface (PI) Layer** (`Eclipse SWT PI/<platform>/`)
   - JNI bindings to native OS APIs
   - Bridge between Java and C/Objective-C
   - Central class: `OS.java` (contains all native method declarations)

### GTK-Specific Architecture (Linux)

**Communication Flow:**
```
Java Application
    ↓
SWT Widget (e.g., Button.java)
    ↓
OS.java (JNI declarations)
    ↓
os.c / os_custom.c (JNI implementation)
    ↓
GTK C Library (gtk_widget_*, g_object_*, etc.)
    ↓
Native Linux Window System
```

**Key Components:**

**OS.java** (`Eclipse SWT PI/gtk/org/eclipse/swt/internal/gtk/OS.java`)
- Central bridge between Java and GTK
- Contains all native method declarations
- Static bindings: `public static final native long gtk_button_new();`
- Dynamic bindings: `@method flags=dynamic` for version-specific APIs
- GTK constants and enums as Java static fields
- Thread-safe locking around native calls

**Native Library Files** (`Eclipse SWT PI/gtk/library/`)
- `os.c` - **Auto-generated** JNI bindings (DO NOT EDIT DIRECTLY)
- `os.h` - Manually edited header with special signatures
- `os_custom.c` - Custom C code including SWTFixed container
- `os_custom.h` - Custom function signatures
- `os_stats.*` - **Auto-generated** statistics tracking
- `Makefile` - Build configuration

**SWTFixed Container**
- Custom GTK container widget defined in `os_custom.c`
- Enables absolute positioning with proper Z-order (not standard in GTK)
- Every SWT widget is based on SWTFixed (allocated in `createHandle()`)
- Uses custom `gtk_widget_show_unraised()` to control draw order
- Critical for SWT's layout model

**GTK Version Support:**
- GTK3: Minimum version 3.22+ (defined in `Display.java`)
- GTK4: Experimental support under active development
- Runtime selection via `GTK_VERSION` environment variable (3.0 or 4.0)
- Version-specific code uses `if (OS.GTK3)` or `if (OS.GTK4)` checks
- Dynamic loading for version-specific functions

### Widget Hierarchy

All widgets extend the base `Widget` class:

```
Widget (base class)
├── Control (visible widgets with handles)
│   ├── Button, Label, ProgressBar, Sash, Scale, Slider
│   └── Scrollable (scrollable controls)
│       ├── Composite (container widgets)
│       │   ├── Canvas, Shell, TabFolder, ToolBar
│       │   ├── Table, Tree (complex viewers)
│       └── List, Text (simple scrollables)
├── Item (non-control widgets)
│   ├── MenuItem, TabItem, TableItem, TreeItem, ToolItem
├── Menu, ScrollBar, Caret
```

**Key Widget Methods:**

- `createHandle()` - Allocates native widget handles (OS-specific)
- `releaseWidget()` - Cleanup and disposal
- `checkWidget()` - Validates widget state before operations
- Handle accessors:
  - `handle` - Primary native handle
  - `fixedHandle` - SWTFixed container handle (GTK)
  - `topHandle()` - Topmost handle for reparenting
  - `parentHandle()` - Parent widget handle
  - `fontHandle()` - Handle to query font from

## Development Workflows

### Adding New GTK Functions to OS.java

When you need to call a new GTK function from SWT:

1. **Add native method declaration to OS.java:**
   ```java
   /**
    * @param widget cast=(GtkWidget *)
    * @param property_name cast=(const gchar *)
    */
   public static final native void _gtk_widget_set_property(long widget, byte[] property_name, long value);
   public static final void gtk_widget_set_property(long widget, byte[] property_name, long value) {
       lock.lock();
       try {
           _gtk_widget_set_property(widget, property_name, value);
       } finally {
           lock.unlock();
       }
   }
   ```

2. **For version-specific functions**, add `@method flags=dynamic`:
   ```java
   /** @method flags=dynamic */
   public static final native long _gtk_some_new_function(long widget);
   ```

3. **If dynamic, add signature to os_custom.h:**
   ```c
   #define gtk_some_new_function_LIB LIB_GTK
   ```

4. **Clean and rebuild** the `org.eclipse.swt` project in Eclipse
   - This regenerates `os.c` from the Java source
   - SWT Tools JNI generator processes the JavaDoc annotations

5. **Rebuild native libraries:**
   ```bash
   cd bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library
   ./build.sh -gtk3 install
   ./build.sh -gtk4 install
   ```

**JavaDoc Annotation Reference:**
- `@param name cast=(Type *)` - C type casting for parameters
- `@method flags=dynamic` - Load function dynamically at runtime
- `@method flags=const` - Function is const-qualified
- `@method flags=no_gen` - Skip JNI generation (manual implementation in os_custom.c)

### Modifying Widget Behavior

**Typical workflow for enhancing a widget:**

1. **Research platform capabilities** - Check GTK/Win32/Cocoa documentation
2. **Update Java implementation** - Modify widget class in `Eclipse SWT/<platform>/`
3. **Add native bindings if needed** - Update `OS.java` and rebuild natives
4. **Test with snippets** - Create/run snippet in `org.eclipse.swt.snippets`
5. **Write JUnit tests** - Add tests to `org.eclipse.swt.tests.<platform>`
6. **Update all platforms** - Ensure GTK/Win32/Cocoa consistency

**Example: Adding a new property to Button**

1. Check if GTK/Win32/Cocoa support the feature natively
2. Add getter/setter to `Button.java` in each platform
3. If new GTK function needed, add to `OS.java`
4. Implement in `createHandle()` or `checkStyle()`
5. Test with `SnippetXXX.java`

### Debugging Native Code

**Quick GDB debugging:**
```bash
# Terminal 1: Run SWT application
java -cp swt.jar:app.jar MyApp

# Terminal 2: Find PID and attach
jps
gdb -pid <java_pid>

# In GDB
(gdb) bt              # Backtrace
(gdb) info threads    # Show threads
(gdb) break gtk_button_clicked
(gdb) continue
```

**Full debugging with symbols:**
1. Rebuild SWT natives with debug flags:
   ```bash
   cd bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library
   ./build.sh -g -gtk3 install
   ```

2. (Optional) Rebuild GTK from source with debug symbols
3. Set `LD_LIBRARY_PATH` to custom GTK build
4. Attach Eclipse CDT debugger or use GDB

**See `docs/gtk-dev-guide.md` for comprehensive debugging instructions.**

### Testing Changes

**Run snippets (fastest iteration):**
```bash
cd examples/org.eclipse.swt.snippets/src/org/eclipse/swt/snippets
# Edit/create SnippetXXX.java
# Run as Java Application in Eclipse
```

Snippets are small, standalone programs demonstrating specific SWT features.

**Run ControlExample (comprehensive):**
```bash
cd examples/org.eclipse.swt.examples
# Run ControlExample.java
# Interactive showcase of all SWT widgets
```

**Run JUnit tests:**
```bash
mvn verify -pl tests/org.eclipse.swt.tests.gtk
# Or run specific test class in Eclipse IDE
```

**Useful environment variables:**
- `GTK_DEBUG=geometry` - Display detailed frame sizes
- `GTK_VERSION=3.0` or `GTK_VERSION=4.0` - Force GTK version
- `LD_LIBRARY_PATH=/custom/gtk/lib` - Use custom GTK build
- `SWT_GTK3=0` or `SWT_GTK3=1` - Alternative version selector

### Working with DPI and Zoom

SWT provides cross-platform DPI utilities:

- `DPIUtil.java` - Platform-independent DPI utilities
- `AutoscaleImageDataProvider.java` - Automatic image scaling
- Platform-specific: `Win32DPIUtils.java`, `GTKDPIUtils.java`, `CocoaDPIUtils.java`

**Recent architecture change:** Zoom-level handling has been consolidated into `DPIUtil` for cross-platform consistency.

**When working with images and bounds:**
- Use `DPIUtil.autoScaleUp()` / `autoScaleDown()` for coordinate conversions
- Provide @2x versions of images for high-DPI displays
- Test on 100%, 150%, 200% zoom levels

## Essential Development Rules

### 1. OSGi Bundle Dependencies

**Check MANIFEST.MF before using classes!**

```
bundles/org.eclipse.swt/META-INF/MANIFEST.MF
```

SWT is an OSGi bundle. Imports must be declared in `MANIFEST.MF`:
```
Export-Package: org.eclipse.swt,
 org.eclipse.swt.widgets,
 org.eclipse.swt.graphics,
 ...
```

If you need to use a class not currently accessible, add the package to `Import-Package` or `Require-Bundle`.

### 2. Resource Disposal

**Critical Memory Management Rule:**

**YOU MUST DISPOSE:**
- Custom `Color`, `Font`, `Image`, `Region`, `Path`, `Pattern`
- `GC` (Graphics Context) objects
- `Cursor` objects you create

**DO NOT DISPOSE:**
- System colors: `Display.getSystemColor(SWT.COLOR_*)`
- System fonts: `widget.getFont()` (unless you called `setFont()` with custom font)
- Images from `ImageRegistry`
- Display/Shell (disposed by framework)

**Pattern:**
```java
Color custom = new Color(display, 255, 0, 0);
try {
    // Use custom color
} finally {
    custom.dispose();
}
```

### 3. UI Thread Requirements

**All SWT code must run on the Display thread!**

```java
Display display = Display.getDefault();

// From non-UI thread
display.asyncExec(() -> {
    // Safe to call SWT methods here
    button.setText("Updated");
});

// Or synchronous
display.syncExec(() -> {
    // Blocks until executed
});
```

**Common mistake:** Updating UI from background threads causes native crashes.

### 4. Platform-Specific Code

**Avoid platform-specific details in Javadoc** - Keep public API documentation platform-agnostic.

**When implementing cross-platform features:**
1. Define API in common widget class
2. Implement in each platform: gtk/, cocoa/, win32/
3. Use fallback behavior if platform doesn't support feature
4. Document behavioral differences in implementation comments

**Platform detection:**
```java
if (OS.isLinux) { /* GTK-specific */ }
if (OS.isWindows) { /* Win32-specific */ }
if (OS.isMac) { /* Cocoa-specific */ }
```

### 5. JNI Coding Standards

**Native method naming:**
- Public wrapper: `gtk_widget_show(long widget)`
- Private native: `_gtk_widget_show(long widget)` (underscore prefix)
- Locking pattern (always required):
  ```java
  public static final void gtk_function(long handle) {
      lock.lock();
      try {
          _gtk_function(handle);
      } finally {
          lock.unlock();
      }
  }
  ```

**Long vs Int for handles:**
- Use `long` for all native pointers/handles (64-bit safe)
- Legacy code may have `int`, but new code should use `long`

### 6. Code Style

- **Method access:** Default (package-private) unless explicitly needed otherwise
- **GTK function naming:** Use `gtk_function_name` format (snake_case for GTK bindings)
- **Assertions:** Used throughout code, enabled in tests with `-ea` VM argument
- **Comments:** Explain "why," not "what" (code is self-documenting)

### 7. Build Properties

When adding new files or packages, update:
```
bundles/org.eclipse.swt/build.properties
```

This tells the OSGi build system which files to include in the bundle JAR.

## Testing

### Test Structure

Tests mirror the production bundle structure:
- `org.eclipse.swt.tests` - Cross-platform widget tests
- `org.eclipse.swt.tests.gtk` - GTK-specific tests
- `org.eclipse.swt.tests.cocoa` - macOS tests
- `org.eclipse.swt.tests.win32` - Windows tests

### JUnit Best Practices

**Prefer JUnit 5 (Jupiter):**
```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterEach;

class ButtonTest {
    private Display display;
    private Shell shell;

    @BeforeEach
    void setUp() {
        display = Display.getDefault();
        shell = new Shell(display);
    }

    @AfterEach
    void tearDown() {
        if (shell != null && !shell.isDisposed()) {
            shell.dispose();
        }
    }

    @Test
    void testButtonCreation() {
        Button button = new Button(shell, SWT.PUSH);
        assertNotNull(button);
        assertTrue(button.isVisible());
    }
}
```

**Test disposal:**
- Always dispose widgets in `@AfterEach`
- Use `if (!widget.isDisposed())` checks
- Avoid `Display.dispose()` (shared across tests)

**UI thread in tests:**
```java
@Test
void testAsyncOperation() {
    display.asyncExec(() -> {
        button.setText("Async");
    });

    // Pump events until operation completes
    while (display.readAndDispatch()) {}

    assertEquals("Async", button.getText());
}
```

### Running Tests

**Maven:**
```bash
mvn verify                                    # All tests
mvn verify -pl tests/org.eclipse.swt.tests   # Specific test bundle
mvn verify -Dtest=ButtonTest                 # Specific test class
```

**Eclipse IDE:**
- Right-click test class → Run As → JUnit Test
- Ensure platform fragment (e.g., `org.eclipse.swt.gtk.linux.x86_64`) is in workspace

## Troubleshooting

### Common Issues

**1. "No more handles" error**
- **Cause:** Forgot to dispose SWT resources (Color, Font, Image, GC)
- **Fix:** Add `resource.dispose()` in finally blocks or tearDown

**2. "Widget is disposed" exception**
- **Cause:** Accessing widget after disposal or from wrong thread
- **Fix:** Check `widget.isDisposed()` before use; ensure UI thread

**3. "Invalid thread access" exception**
- **Cause:** Calling SWT methods from non-UI thread
- **Fix:** Wrap in `display.asyncExec()` or `display.syncExec()`

**4. Native crashes (SIGSEGV)**
- **Cause:** Usually JNI issues - wrong pointer types, disposed handles, thread issues
- **Fix:** Use GDB to get backtrace, check native call parameters

**5. Build fails with "Cannot find os.c"**
- **Cause:** Auto-generated files not created
- **Fix:** Clean and rebuild `org.eclipse.swt` project in Eclipse first, then run Maven

**6. Tests fail with "No display available"**
- **Cause:** Running on headless system without X11/Wayland
- **Fix:** Use Xvfb: `xvfb-run mvn verify`

**7. GTK version mismatch warnings**
- **Cause:** Runtime GTK version older than compile-time version
- **Fix:** Update GTK packages or rebuild natives for older GTK

**8. Native library not found**
- **Cause:** Missing `binaries/org.eclipse.swt.<platform>/` fragment
- **Fix:** Ensure platform fragment is in workspace/build

### Debug Logging

**Enable SWT debug output:**
```java
// In Display.java, uncomment debug statements
System.setProperty("swt.debug", "true");
```

**GTK debug output:**
```bash
export G_MESSAGES_DEBUG=all
export GTK_DEBUG=all
java -Dswt.debug=true -cp ... MyApp
```

## Important Files

**Core SWT Classes:**
- `bundles/org.eclipse.swt/Eclipse SWT/common/org/eclipse/swt/widgets/Widget.java` - Base widget class
- `bundles/org.eclipse.swt/Eclipse SWT/gtk/org/eclipse/swt/widgets/Display.java` - GTK version requirements, main event loop
- `bundles/org.eclipse.swt/Eclipse SWT PI/gtk/org/eclipse/swt/internal/gtk/OS.java` - All GTK bindings

**Native Code:**
- `bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library/os_custom.c` - SWTFixed and custom native code
- `bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library/os_custom.h` - Custom signatures
- `bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library/os.h` - JNI headers
- `bundles/org.eclipse.swt/Eclipse SWT PI/gtk/library/Makefile` - Build configuration

**Documentation:**
- `README.md` - Getting started, contributing
- `docs/gtk-dev-guide.md` - **Essential reading for GTK work** (1000+ lines)
- `bundles/org.eclipse.swt/Readme.Linux.md` - GTK-specific information
- `bundles/org.eclipse.swt/Readme.macOS.md` - macOS-specific information
- `bundles/org.eclipse.swt/Readme.Win32.md` - Windows-specific information
- `bundles/org.eclipse.swt/Readme.WebView2.md` - Browser widget on Windows

**Build Files:**
- `bundles/org.eclipse.swt/META-INF/MANIFEST.MF` - OSGi bundle manifest
- `bundles/org.eclipse.swt/build.properties` - PDE build configuration
- `bundles/org.eclipse.swt/pom.xml` - Maven/Tycho configuration

## Additional Resources

- **SWT Website:** https://www.eclipse.org/swt/
- **Bug Tracker:** https://github.com/eclipse-platform/eclipse.platform.swt/issues
- **Eclipse Forum:** https://accounts.eclipse.org/mailing-list/platform-dev
- **SWT Javadoc:** https://help.eclipse.org/latest/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/package-summary.html
- **GTK Documentation:** https://docs.gtk.org/gtk3/ and https://docs.gtk.org/gtk4/
- **Win32 API:** https://learn.microsoft.com/en-us/windows/win32/api/
- **Cocoa Documentation:** https://developer.apple.com/documentation/appkit

## AI Agent Guidelines

**When assisting with SWT development:**

1. **Always check platform context** - Is this GTK, Win32, or Cocoa code?
2. **Verify native bindings** - Check if OS.java already has the needed function
3. **Consider resource disposal** - Remind users to dispose custom resources
4. **Thread safety** - Ensure UI operations are on Display thread
5. **Test recommendations** - Suggest relevant snippets or existing tests
6. **Build awareness** - Remember the Tycho build system quirks
7. **Cross-platform consistency** - Consider all platforms when suggesting changes
8. **Generated code** - Never edit `os.c`, `os_stats.*` directly
9. **Documentation links** - Reference platform docs (GTK, Win32, Cocoa)
10. **Backward compatibility** - SWT has strong API compatibility requirements

**Common user requests:**
- "How do I add GTK function X?" → Guide through OS.java workflow
- "Why does my widget crash?" → Check disposal, threading, JNI parameters
- "How do I test this?" → Suggest snippet creation or existing test patterns
- "Why won't this build?" → Check if they need to rebuild natives, clean project
- "How do I debug native code?" → Point to gtk-dev-guide.md and GDB workflow

**Be proactive about:**
- Suggesting cross-platform implementation when user modifies one platform
- Warning about generated files (os.c)
- Reminding about resource disposal
- Checking for existing tests before suggesting new ones
- Verifying MANIFEST.MF when introducing new dependencies
